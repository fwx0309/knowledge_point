#### JVM垃圾回收机制，GC发生在JVM哪部分，有几种GC，他们的算法是什么

1. #### GC发生在JVM哪部分

   GC发生在堆（heap）内存中

2. #### 有几种GC

   分代收集算法：

   - 次数上频繁收集Young区（年轻代）	Minor GC
   - 次数上较少收集Old（老年代）	Full GC
   - 基本不动Perm区（永久区是没有GC的）

3. #### GC的算法

   1. ##### 引用计算法

      如果对象有被引用GC就不会进行垃圾回收。

      已经被JVM淘汰：

      - 每次对对象赋值时均要维护引用计数器，切计数器本身也有一定的消耗；
      - 因为无法处理循环引用；

   2. ##### 复制算法（Copying）

      **年轻代**中使用的是Minor GC这种GC算法采用的是复制算法（Copying）

      **原理：**

      （从一个内存空间复制到另外一个内存空间，需要双倍的空间，复制后的内存空间是连续的）

      - 从根集合（GC Root）开始，通过Tracing从From中找到存活对象，拷贝到To中；
      - From、To交换身份，下次内存分配从To开始；

      **优势：**

      - 没有标记个清除的过程，效率高
      - 没有内存碎片，可以利用bump-the-pointer实现快速内存分配

      **缺点：**

      ​	需要双倍的空间

   3. **标记清除（Mark-Sweep）**

      发生在**老年代**

      **原理：**

      ​	标记：从根集合开始扫描，对存活的对象进行标记。

      ​	清除：扫描整个内存空间，回收未被标记的对象，使用free-list记录可用区域。

      **优势：**

      ​	不需要额外空间

      **缺点：**

      ​	两次扫描，耗时严重；会产生内存碎片；

   4. ##### 标记压缩（Mark-Compact）

      发生在**老年代由**标记清除与标记整理的混合实现

      **原理：**

      ​	标记：与标记清除一样。

      ​	压缩：再次扫描，并往一端滑动存活对象。

      ​	（在整理压缩阶段，不再对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存）

      **优点：**

      ​	没有内存碎片，可以利用bump-the-pointer

      **缺点：**

      ​	需要移动对象的成本

   5. **标记清除压缩**（Mark-Sweep-Compact）

      **原理：**

      1. Mark-Sweep 和 Mark-Compact 的结合
      2. 和 Mark-Sweep  一致,当进行多次GC后才Compact 。

      **优点：**

      ​	减少移动对象的成本 

      